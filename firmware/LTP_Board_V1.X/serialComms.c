#include "mcc_generated_files/uart1.h"
#include "serialComms.h"
#include "cobs.h"
#include "LTP_system.h"
#include <string.h>

//#define _DEBUG
#include "dbg.h"

uint8_t buff_RxUnstuffed[255];
uint8_t buff_RxStuffed[255];
uint8_t buff_TxStuffed[255];
size_t tempLength;
size_t TxPacketLength;

static uint8_t serial_buffer[255];
static uint16_t serial_buffer_length = 0;
static bool serial_packet_good = false;
static uint8_t packet_buffer[255];

uint8_t DELIMETER = 0;

/**
 * This function works in conjuntion with the UART1_ MCC autogenerated commands 
 * which monitor the UART interrupts and buffer the Rx input. This allows us to poll it, but gives us a 
 * deeper buffer. It would have been better to just do a byte by byte analysis of this, but hey the 
 * code is done. If the packet is clean from start to finish, this function also sets the serial_packet_good
 * boolean. 
 * @return packet_length. 
 */
static int SerialReadPacket();

int sendLTPSample(struct LtpSample *sendSample) {
    // convert the LTPSample to a byte array
    uint8_t *sampleBytes = (uint8_t*) sendSample;

    // this byte array is our "input" array. Get the length of it
    TxPacketLength = sizeof (struct LtpSample);

    // Make sure our tx packet is not too long. This should never happen
    if (TxPacketLength >= 251)
        return 0;

    // encode the "input" array with COBS. Encode it to our buffer array, buff_TxStuffed
    tempLength = cobs_encode(sampleBytes, TxPacketLength, buff_TxStuffed);

    // Make sure our encoded COBS packet is not too long. If it is longer than 255 that it 
    // won't be able to be decoded
    if (tempLength >= 253)
        return 0;

    int i;
    for (i = 0; i < tempLength; i++) {
        // write the current byte.
        UART1_Write(buff_TxStuffed[i]);

        // Wait for the transmission to complete
        while (!(UART1_StatusGet() & UART1_TX_COMPLETE)) {
        }
    }

    // Terminate our COBS packet with a 0x00
    UART1_Write(0x00);
    while (!(UART1_StatusGet() & UART1_TX_COMPLETE)) {
    }

    return 1;
}

int ReadLtpCommand(struct LtpCommand *ltp_command) {
    uint8_t decode_buff[255];
    size_t decode_buff_length;
    
    int read_packet_length = SerialReadPacket();

    // we have a packet!
    if (read_packet_length > 0 && serial_packet_good) {
        // check to see if it is under our size limit and if the end has a delimieter
        if(read_packet_length >= 254 || packet_buffer[read_packet_length - 1] != DELIMETER) {
            return 0;
        }
        
        // decrement the packet length to get rid of the trailing zero
        read_packet_length--;
        
        decode_buff_length = cobs_decode(packet_buffer, read_packet_length, decode_buff);
        
        if(!decode_buff_length)
            return 0;
        
        *ltp_command = *(struct LtpCommand*)decode_buff;
        return 1;
        
    }
    return 0;
}

static int SerialReadPacket() {

    while (!UART1_ReceiveBufferIsEmpty()) {

        // buffer overflow
        if (serial_buffer_length >= 254) {
            serial_packet_good = false;
            serial_buffer_length = 0;
        }

        int bytes_read = UART1_ReadBuffer(serial_buffer + serial_buffer_length, 8);
        serial_buffer_length += bytes_read;

        // check to see if we overflowed after a serial read
        if (serial_buffer_length >= 254) {
            serial_packet_good = false;
            serial_buffer_length = 0;
        } else if (bytes_read > 0) {
            // We scan the just read portion for a delimeter
            int i;
            for (i = serial_buffer_length - bytes_read; i < serial_buffer_length; i++) {
                if (serial_buffer[i] == DELIMETER) {
                    // We have found a delimeter
                    // Copy over the packet 
                    memcpy(packet_buffer, serial_buffer, i + 1);

                    // Set our serial buffer to contain whatever came after the delimeter
                    serial_buffer_length = serial_buffer_length - i - 1;
                    memcpy(serial_buffer, serial_buffer + i + 1, serial_buffer_length);

                    if (serial_packet_good)
                        return i + 1;

                    serial_packet_good = true;
                }
            }
        }
    }
    return 0;
}